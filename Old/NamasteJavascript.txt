
-> Every thing in javascript run in the execution context
   - Memory component ( variable Enviroment )
      - Memory creation phase
   - code component ( Thread of execution )
      - code execution phase
-> javascript is a synchronous , single threaded programming language
-> P: arameter = Placeholder (in the function definition)
   A: rgument = Actual Value (when calling the function)
-> Call Stack - Bottom of every call stack we have Global Execution Context
-> call stack maintains the order of execution of execution contexts

--> hoisting is a phenomenon is js by which we can access the variables and functions even before we have initialized it , without any error
--> allocation of memory to variables and functions before assigning is called hoisting

--> scope is directly depend on the lexical environment
--> lexical environment is created when execution context is created
--> lexical environment is the local memory along with the lexical environment of its parent
--> lexical means heirarichy or sequence 
--> c() function is lexically sitting inside the a() function

--> temporal dead zone - It is the time since when this let or const variable was hoisted and till it was assigned a value , the time between this is known as temoral dead zone
--> for let and const hoisting , they are hoisted but not in the global scope ( they are hoisted in a different memory space , we can see as Script in chrome dev tools ) 

--> Closures are functions bundled with their lexical environment
    - Ex: SetTimeout and passing functions as arguments
--> currying in javascript is possible just because of closures
  - Currying is a functional-programming technique where you transform a function that takes multiple arguments into a sequence of functions, each taking a single argument

--> Data hiding is done in js with the help of closures ( which was done with functions )
--> disadvantages of closures  - over consumption of memory
--> if the child function is not using the parent function varibles , then those varibles are garbage collected
    - Mark and sweep algorithm is used to clean up the unused memory

--> A â€œhigher-order functionâ€ is a function that accepts functions as parameters and/or returns a function
--> difference between function statement and expression is hoisting
        - A function expression assigns a function (anonymous or named) to a variable
        - A function statement declares a function with a name
--> First Class Functions : the ability to use the functions as values  and can be passed as an argument to another function
    and can be returned out of another a function is called First Class Functions

--> event loop has one job , that too continuously check the callstack and call back queue , if it find call stack empty and callback queue with 
  some calllback function then it simply moves it from callback queue to the call stack 
    - callback functions like event listeners or settimeout will go to callback queue
    - microtasks like promises or mutation observers will go to microtask queue
    - microtasks queue has higher priority than callback queue
    - the callback queue is also known as the macrotask queue

--> Type	        Queued By	                                    When It Runs
    Microtask	    .then, catch, await	                            After the current JS call stack clears
    Macrotask	    setTimeout, setInterval, Dom Events     	    After microtasks have finished

    Ex:
        setTimeout(() => console.log("setTimeout"), 0);
        Promise.resolve().then(() => console.log("promise"));

--> interpreter will make the code run more fast
    - this will start execution directly line by line , without any previous steps like parsing 
--> compiler will make our code more efficeint by optimizing our code ( effeciency ) , before running
--> our browser use both compiler and interpreter whis is know as JIT compiler
--> JavaScript Runtime Enviroment ( v8 Engine ) - code -> parsing -> compilation -> execution 
    - Parsing is the process of taking raw source text (your JavaScript code or data) and turning it into a structured representation that the JavaScript engine can work with
    - These tokens are fed into a parser, which checks that they compile to JavaScript's grammar and builds an Abstract Syntax Tree (AST).

--> prototype inheritance , polyfill
    - Array.prototype.calucalate will make the calucalate method available to all arrays
    - if we are using the radius =[] , then to use radius inside calculate with radius.calculate we need to use this keyword which will provide us the radius arrays
    EX: Array.prototype.calculate = function(fn) {
        return this.map(fn);
        };
        const radius = [1, 2, 3, 4];
        const area = radius.calculate(function(r) {
        return Math.PI * r * r;
        });
        console.log(area); // [3.14..., 12.56..., 28.27..., 50.26...]
    
--> everything in javascript are objects
--> each and every object in java script has a prototype
    - prototype chain - arr.__proto__ was from Array.prototype -> arr__proto__.__proto__ was from Object.prototype -> Object.prototype.__proto__ is null
--> when ever we create something in js , we get some default hidden properties and that is through protoype inheritance
--> every thing in js is object ,, when ever we create an object in js , all default functions will be creted as an object and jre adds it to our each and every  object
--> to write a polyfill for a funcion , Function.prototype.methodName = function() {}

--> if we have nested events and if we dont define capture keywored , then by default event bubbling will happen , event capturing is the opposite order of the events execution of event bubbling , event trickling is nothing but event capturing
--> if we have both event bubbling and capturing ,, irrespective of the origin first capturing occurs then , event bubbling occurs 
--> e.stopPropagation() ,, this is to stop the event bubbling or capturing 
--> Event Delegation is a pattern based upon the concept of Event Bubbling. It is an event-handling pattern that allows you to handle events at a higher level in the DOM tree other than the level where the event was first received
        - https://www.freecodecamp.org/news/event-delegation-javascript/
        - The idea is that you "delegate" the handling of an event to a different element (in this case, the div, which is a parent element) instead of the actual element (the button) that received the event
        - With event delegation, you create fewer event listeners and perform similar events-based logic in one place
        - instead of adding a event listener to each and every child , we can add a single event listener to the parent ,, and make that trigger for each child click
--> Event Propagation determines in which order the elements receive the event. There are two ways to handle this event propagation order of HTML DOM is Event Bubbling and Event Capturing

--> if we do any normal function call ,, by default it assumes that there is window on the left side like window.fun() === fun()
--> we can pass args to anonymous func despite if not having params and we can print it with console.log(arguments) ,, but with arrow functions it wont

--> the dynamic nature of this keyword inside functions is one of the reasons we have reusability of code 

--> whenever we do a cors request , before this an preflight options call will be made , with the additional headers wer are going to use and if that gets error , we are now allowed to use those additional headers
        - https://grok.com/chat/45979a62-40d7-4259-805e-0208084c7299

--> Debounce: ignores intermediate events, runs once after activity stops. Ex: Search box , Auto-saving forms
    Throttle: runs at most once every X ms, even if events continue to fire. Ex: Resize event handlers , Scroll-triggered animations and Button click spam protection
    - Use debounce for â€œonly after the user stopsâ€ (search, resize), and throttle for â€œat a steady rateâ€ (scroll position, progress updates)
--> The rest and spread operators in JavaScript both use the ... (three dots) syntax, but they do opposite things depending on where they're used
    - Rest Operator (... in function parameter or destructuring) - Collects multiple values into a single array.
    - Used in object or array destructuring - const [first, ...rest] = [1, 2, 3, 4];
    - Expands an array (or object) into individual a.
    - Syntax location	Left side of = or params ( Rest )	Right side of = or args ( Spread )

--> callback hell : Pyramid of doom 
    - inversion of control - we were passing a callback to anohter function and trusting that it will be called , which we can loose control of
--> A promise is an object which represents the eventual completion or failure of an asynchronous operation.
    - promise chaining get helps us get out of call back hell
    - Promise(function(resolve, reject) {}) constructor will take a function and that function has resolve and reject which will be provided by the Promise API in JS
    - The then() method is defined in the Promise prototype, and its job is to return a new promise that represents the result of the callback you pass into it
        - new Promise(function(resolve,reject){resolve("you got successful")}).then((info) => {console.log(info)})
        - this will give you the PromiseResult as undefined because in the .then promise we are not returning anything
    - if we have .catch() in a promise chain , and if we got any rejects in the top of the chain that will be handled by this catch
    - Promise.race() - will return the first settled promise ( whether its a fullfilled or reject )
    - Promise.any()  - will retutn the first settled fulfilled promise ( kind of success seeking race )
            - If all promises in .any() fails the result will be the AggregateError
            - for the array of AggregateError we can use err.errors in .catch()
    - you can't "pause" or "cancel" promises once they start (unless you wrap them in something like AbortController)
    - [[PromiseReactions]] - Queue of handlers(callbacks) waiting to run when the promise settles

--> Async and Await are used to handle promises
    - By default Async functions return a Promise
    - even if we return something like string in this async function , it will wrap this string in promise and it will return
    - whenever JS engine sees await keyword , it will suspend the execution of the function and will wait for the promise to settle , by moving that execution to microtask queue
    - Async and await is just a syntactical sugar over promise chaining , under the hood it uses promise chaining

--> This will be undefined in strict mode
    - To use strict mode add "use strict" in the top of the js file
    - ( this substitution ) - in non strict mode if this keyword is null or undefined , then it will be replaced with globalObject ( window in browser and global in nodejd)
    - this keyword depends on how the function is called ( if this keyword was present inside function )
    - if we make a function as part of an object then that will be called as method
    - If this keyword was present inide a method then this keyword will represent that object
    - this keyword in DOM elements represents the referece of the HTMLElement itself
    - strict js doesnt allow window inside a function ,, instead we can use this which was same 
    - 'this' keyword in arrow function is same like as it in the outside 

--> JavaScript provides three methods for manipulating the 'this' keyword in functions: call(), apply(), and bind(). These methods allow you to change the context of the 'this' keyword, which can be useful for controlling the behaviour of functions
    - DEFINATION : call, apply, and bind are methods used to manipulate the this context of a function and control how arguments are passed. call and apply immediately invoke the function, while bind creates a new function with a specified this context that can be invoked later
    - Arrow functions do not bind their own this, arguments, super, or new.target. Instead, they lexically inherit these from the enclosing (parent) execution context.
    - That means the this keyword inside an arrow function is the same as this keyword outside it â€” unlike normal functions, which bind this keyword dynamically depending on how they're called
    - if we define a this inside of a function in an object , if that fuction is arrow function , then 'this' keyword refers to the Window and if we use normal function then this keyword refers to the object
    - Explicit binding , Function borrowing











--> Things learned:
1. let and const are hoisted but its memory is allocated at other place than window which cannot be accessed before initialisation.
2. Temporal Dead Zone exists until variable is declared and assigned a value.
3. window.variable OR this.variable will not give value of variable defined using let or const.
4. We cannot redeclare the same variable with let/const(even with using var the second time).
5. const variable declaration and initialisation must be done on the same line.
6. There are three types of error: [1] referenceError {given where variable does not have memory allocation} [2] typeError {given when we change type that is not supposed to be changed} [3] syntaxError {when proper syntax(way of writing a statement) is not used}.
7. Use const wherever possible followed by let, Use var as little as possible(only if you have to). It helps avoid error.
8. Initialising variables at the top is good idea, helps shrinks TDZ to zero.

--> 1. When JavaScript code is executed, Execution Context is created and it is called Global Execution Context.
2. JavaScript program is executed in TWO PHASES inside Execution Context
  a. MEMORY ALLOCATION PHASE - JavaScript program goes throughout the program and allocate memory of Variables and Functions declared in program.
  b. CODE EXECUTION PHASE -  JavaScript program now goes throughout the code line by line and execute the code. 
3. A Function is invoked when it is called and it acts as another MINI PROGRAM and creates its own Execution Context.
4. Returns keyword return the Control back to the PREVIOUS Execution-Context where the Function is called and Execution Context of the Function is DELETED.
5. CALL STACK maintains the ORDER of execution of Execution Contexts. It CREATES Execution Context whenever a Program starts or a Function is invoked and it pops out the Execution Context when a Function or Program ENDS.

--> Summary:

1. In JS, before the code is executed, the variables get initialized to undefined.
2. Arrow functions enact as variables and get "undefined" during the memory creation phase while functions actually get run.
3. Hoisting: Mechanism in JS where the variable declarations are moved to the top of the scope before execution. Therefore it is possible to call a function before initializing it.
4. Whenever a JS program is run, a global execution block is created, which comprises of 2: Memory creation and Code execution


--> Summary:

1. We learnt how functions work in JS.
2. At first a global execution context is created, which consists of Memory and code and has 2 phases: Memory allocation phase and code execution phase.
3. In the first phase, the variables are assigned "undefined" while functions have their own code.
4. Whenever there is a function declaration in the code, a separate local execution context gets created having its own phases and is pushed into the call stack.
5. Once the function ends, the EC is removed from the call stack.
6. When the program ends, even the global EC is pulled out of the call stack.

--> Summary

1. Undefined is like a placeholder till a variable is not assigned a value.
2. undefined !== not defined
3. JS- weakly typed language since it doesn't depend on data type declaration

-->
Closure :Function bundled with its lexical environment is known as a closure. Whenever function is returned, even if its vanished in execution context 
but still it remembers the reference it was pointing to. Its not just that function alone it returns but the entire closure and that's where 
it becomes interesting

--> Wow, these are some of the best doubts. â¤ï¸
1. When does the event loop actually start? - Event loop, as the name suggests, is a single-thread, loop that is `almost infinite`. It's always running and doing its job. â¤ï¸
2.  Are only asynchronous web API callbacks are registered in the web API environment? - YES, the synchronous callback functions like what we pass inside map, filter, and reduce aren't registered in the Web API environment. It's just those async callback functions that go through all this.
3. Does the web API environment stores only the callback function and pushes the same callback to queue/microtask queue? - Yes, the callback functions are stored, and a reference is scheduled in the queues. Moreover, in the case of event listeners(for example click handlers), the original callbacks stay in the web API environment forever, that's why it's advised to explicitly remove the listeners when not in use so that the garbage collector does its job.
4. How does it matter if we delay for setTimeout would be 0ms. Then callback will move to queue without any wait? 
No, there are trust issues with setTimeout() ðŸ˜…. The callback function needs to wait until the Call Stack is empty. So the 0 ms callback might have to wait for 100ms also if the stack is busy.  It's a very beautiful concept, and I've covered this in detail in the next episode of Namaste JavaScript. ðŸ”¥
Thank you so much for asking all these questions, Shruti. You're a gem

--> Things learned:
1. Browser has superpowers that are lent to JS engine to execute some tasks, these superpowers include web API's such as console, location, DOM API, setTimeout, fetch, local storage.
2. Callback functions and event handers are first stored in Web API environment and then transferred to callback queue.
3. Promises and mutation observer are stored in API environment and then transferred to microtask queue.
4. Event loop continuously observes call stack and when it is empty it transfers task to call stack.
5. Micro task is given priority over callback tasks.
6. Too many micro tasks generated can cause Starvation (nit giving time to callback tasks to execute)



--> Benefits of event delegation:
1) improves memory space
2) mitigates risk of performance bottle neck
3) Dom manipulation
Limitations:
1) All the events are not bubbled up, some events like blur, focus are not bubbled up
2) if e.stopPropogation is used in child, then events are not bubbled up












--> CONSTRUCTOR FUNCTIONS , PROMISES , MICROSTACK QUEUE , THIS IN ARROW FUNCTION , 




