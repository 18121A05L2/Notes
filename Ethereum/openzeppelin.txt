-> The EnumerableSet library from OpenZeppelin provides a powerful tool for managing collections of unique values in Solidity. It offers efficient ways to store, retrieve, and enumerate over sets of data, making it perfect for use cases like access control, governance, and token management.
-> As of now EnumerableSet supports  - Bytes32Set , AddressSet and UintSet
-> About _disableInitializers() - https://grok.com/share/bGVnYWN5_29c70810-f989-40ad-98bc-0f2199e815cc
-> reinitializer() - https://grok.com/share/bGVnYWN5_752bc8fd-3875-4f15-96ff-2f22ccaf6911
-> onlyInitializing - Restricts a function to be called only during an ongoing initialization ( initializer modifier in parent contract )
    - Checks that an initialization is already in progress (via the flag set by initializer) before allowing execution
    - It doesn't start the initialization process itself but works within it
    - Usually internal, as it's meant for use within the contract's inheritance hierarchy
-> Difference between EnumerableSet and EnumerableMap - https://grok.com/share/bGVnYWN5_42cab544-afaf-4ae3-983b-bb738810d04d
-> keyvalue paris of EnumerableMap - https://grok.com/share/bGVnYWN5_afffd22d-1c05-4d8b-aa27-47d379f3d898
->  ERC-7201: Namespaced Storage Layout
    - keccak256(abi.encode(uint256(keccak256(abi.encodePacked(namespace))) - 1)) & ~bytes32(uint256(0xff)) (Performing the AND NOT 0xff operation transforms the rightmost byte of the location to 00. This prepares for a future upgrade when Ethereum switches its storage data structure to Verkle Trees and 256 adjacent slots can be warmed at once)
    - @custom:storage-location <FORMULA_ID>:<NAMESPACE_ID>
    - @custom:storage-location erc7201:pareto.storage.EmergencyUtils
    - Computes the slot via keccak256("pareto.storage.EmergencyUtils")
-> ERC-1967 (EIP-1967) defines unstructured proxy storage slots
    - If you're deploying or interacting with an upgradeable proxy (Transparent or UUPS), you rely on ERC-1967 to manage the proxy's own slots safely 
    - If your logic contract has a complex state spanning multiple facets or concerns, and you want to namespace those state variables to avoid layout drift, adopt ERC-7201 alongside your proxy setup
-> Always use ERC-1967 for proxy deployments to isolate implementation/admin pointers—this is non-negotiable for Transparent or UUPS proxies 
    Opt-in to ERC-7201 when your implementation contract comprises multiple independent modules, mixins, or facets that each define their own state—this prevents internal collisions and eases maintenance
-> Despite ERC-1967 providing a robust solution for segregating proxy metadata (implementation, admin, beacon pointers) from a logic contract's state, it does not address storage collisions within the logic contract itself when that contract spans multiple modules or facets. ERC-7201 fills this gap by introducing a namespaced storage layout: each module declares its own struct annotated with a unique identifier, and the slot is derived via keccak256(namespace), guaranteeing isolation between modules at upgrade time 
. Together, ERC-1967 and ERC-7201 enable end-to-end collision safety across both proxy and application storage in upgradeable systems
-> verkle trees - ~bytes32(uint256(0xff)) - (https://grok.com/share/bGVnYWN5_b1e677c5-cf2c-493e-b157-d45ff866acc6)
    - (https://grok.com/share/bGVnYWN5_4a8e6bde-5001-4989-a4d2-c7d07c1363be)







