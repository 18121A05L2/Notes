-> Ethereum is a global open censorship resistant platform for building decentralized applications
-> Ethereum is the Worlds first verifiable computer
-> counterfactual accounts - A counterfactual account is an account that doesn't exist yet on-chain, but you already know its future address (via CREATE2)
-> proof of innocence is kind of tornado cash but with exclustion list - https://github.com/chainwayxyz/proof-of-innocence
    - Prove they are not withdrawing funds linked to any address on a known “sanctions/exclusion list” — without revealing which deposit is theirs.
-> privacy for the weak and transperancy ( accountability and auditability ) for the powerful
-> Beacon nodes ( consensus ) database was 50-Gb and the execution client has between 500-700 GB
-> We need to run separate consensus and execution clients, which has their own p2p nodes and data will come through consensus to execution 
    through Engine API
-> Putting ur wallet ( private key ) inside the execution client for those key management APIs was dumb
-> 1Ether = 10^18 wei , 1Ether = 10^9 Gwei
-> The state root hash is the hash of the root node of the state trie after the execution of all the transactions included in the block.
-> When a light client needs to verify a specific part of the state (e.g., the balance of an account or the result of a transaction), it can 
    request a Merkle proof from a full node
-> A Merkle proof is a path in the Merkle Patricia Trie from a particular leaf (the account or storage data) up to the state root hash
-> Ethereum 2.0 divides time into periods called epochs (each epoch consists of 32 slots, with each slot lasting 12 seconds) 
    - Assume there are 100,000 active validators. For a block to be justified, at least 66,667 validators (⅔) need to attest to it in an epoch
    - In each epoch, the block in the first slot is a checkpoint. These checkpoints are important because they are used to make sections of the blockchain permanent and irreversible ( justified Epochs and Finalized Epochs )
        - Justified means “enough votes to trust it”
        - Finalized means “locked-in by the next justified checkpoint”
        - A finalized epoch means ≥2/3 validators would need to slash themselves to revert it — economically infeasible.
-> A bug in a consensus client with over 33% of the Ethereum nodes could prevent the consensus layer from finalizing
-> the validator is slashed. This means that 1/64th of their staked ether (up to a maximum of 0.5 ether) is immediately burned, then a 36 day removal period begins
-> Execution Client is not responsible for block building, block gossiping or handling consensus logic
-> Execution Client - home to the Ethereum Virtual Machine, Ethereum's state and transaction pool
-> The consensus client does not participate in attesting to or proposing blocks - this is done by a validator, an optional add-on to a consensus client
-> Node operators can add a validator to their consensus clients by depositing 32 ETH in the deposit contract. The validator client comes bundled with the consensus client and can be added to a node at any time
-> Randomly selecting a subset of 512 validators every 1.1 days to act as a sync committee - The sync committee signs the header of recent blocks which is helpful for Light clients - This means a light client can quickly see that the sync committee has signed off on the data they receive, and they can also check that the sync committee is the genuine one by comparing the one they receive from the one they were told to expect in the previous block -- checked against block headers that they know have been signed by at least 2/3 of a random set of 512 Ethereum validators
-> Currently, light clients rely on RPC requests to full nodes using a client/server model, but in the future the data could be requested in a more decentralized way using a dedicated network such as the Portal Network(opens in a new tab) that could serve the data to light clients using a peer-to-peer gossip protocol
    - Light clients query the Portal Network: Instead of calling a centralized RPC, a wallet or dApp can: Request account state or transaction history directly from peers. Verify responses cryptographically using Merkle proofs.
    - It's part of Ethereum's long-term goal to “empower everyone to run a node”.
    - Helios could fetch data directly from the Portal Network peers, instead of centralized RPCs
-> Ethereum Networking Protocols - Both stacks work in parallel. The discovery stack feeds new network participants into the network, and the DevP2P stack enables their interactions
-> A successful PING-PONG "bonds" the new node to a bootnode
-> start client --> connect to bootnode --> bond to bootnode --> find neighbours --> bond to neighbours
-> storage optimisations and categorises them into replication-based, redaction-based, and content-based optimisations. Replication-based optimisations focus on reducing duplication of blockchain data shared among participants after committing data on the blockchain ledger. Redaction-based optimisations allow users to modify or delete data already committed on the ledger in various ways, while content-based optimisations compress data before or after committing it to the ledger
-> base64 -i example.svg --> data:image/svg+xml;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII
-> On Ethereum there are a few different types of transactions:
    -> Regular transactions: a transaction from one account to another.
    -> Contract deployment transactions: a transaction without a 'to' address, where the data field is used for the contract code.
    -> Execution of a contract: a transaction that interacts with a deployed smart contract. In this case, 'to' address is the smart contract address.
-> The Ethereum blockchain consists of: Whole ( 600 GB )
   State Trie (accounts, storage, balances) → ~250GB
   Transaction History (including logs in receipts) → ~350GB
   Blocks, Headers, and Other Data → Remaining size
   Logs are stored in the transaction history but are not part of the state trie.
   Pruned nodes (like archive nodes vs. full nodes) may discard older logs to save space. 
-> user case and problem : we have created a smart contract wallet with social recovery and we have initialized smart 
    contract account in both ethereum and zksync and you have lost your EOA which you used to initialize the smart contract accounts
    and some one sent you money on optimism and you can't initialize the smart contract account with same address in optimism because
    you have used create2 and lost EOA adddress to initialize and generate the address of smart contract account
-> Why Gas Exist in the first place : Ethereum is a Turing-complete system. Turing-complete systems face the challenge 
    of the halting problem i.e. given an arbitrary program and its input, it is not solvable to determine whether the
    program will eventually stop running. So Ethereum cannot predict if a smart contract will terminate, or how long it
    will run. Therefore, to constrain the resources used by a smart contract, Ethereum introduces a metering mechanism 
    called gas. So, gas is the unit used in Ethereum for measuring and limiting computations per block.
    - Turing-complete means any computable program is possible
    - It can, in theory, execute any computable logic — loops, recursion, conditions, etc.
-> Turing machine - https://grok.com/share/bGVnYWN5_c9eaca24-3cb6-4863-8577-ecded478336f
    - A Turing machine can perform any computation that can be described by an algorithm, given enough time and resources
-> Merge → Surge → Scourge → Verge → Purge → Splurge
-> verge 
    - decreasing node sync time from a couple of days to 10 minutes
    - restart or resynsc can go from 2 days to 10 minutes 
    - and decrease the hardware requirements
    - verfying the blocks with snarks
-> The Purge
    - which involves removing outdated data and simplifying the protocol
    - History Expiration: Nodes might not be required to store all previous blocks, reducing storage requirements
-> Splurge
    - Essentially the cleanup and innovation phase after the core roadmap is complete
-> selfdestruct will let you kill the contract even if the conctract has arbitrary large number of storage slots 
    - this means there is not upper bound on the amount of state within in that could change within in a single block
    - if a contract has a million object and if we selfdestruct this contract then this million objects will go away ( handling this edge case is complex and for this we need to add large amount of extra code on the client developers)
    - hardlimit on number of the storage slots that can change within in a single block
-> The base transaction cost (21,000 gas)
-> Etherem accounts have a state consisting of four key fields: 
    Nonce: A counter that tracks the number of transactions sent from the account, preventing replay attacks.
    Balance: The amount of ETH the account holds.
    Storage Hash: A Merkle root representing the account's storage.
    Code Hash: A hash of the account's associated code (empty for EOAs).
-> shamir backup - social recovery wallet
-> An SRP ( Seed Recovery Phrase ) restores the entire wallet with all its derived accounts, while a Private Key only restores one specific account.
-> Hybrid smart contracts - These smart contracts has a combination of on chain and off chain data and logic
-> BFT (Byzantine Fault Tolerance) consensus is a class of consensus algorithms designed to allow a blockchain network to reach agreement (consensus) even if some(upt to 1/3) of the nodes (participants) are malicious, faulty, or acting arbitrarily
    - a Byzantine Fault Tolerant system can continue to function correctly if up to 1/3 of nodes are faulty or malicious
    - RTT - Round Trip Time
-> Peer scoring algorithms are decentralized reputation systems for network nodes.They help maintain performance, resist spam, and encourage honest behavior —forming the social immune system of P2P protocols.
    - Ethereum (libp2p GossipSub) - for block/attestation gossip
-> The straggler problem in Ethereum is when slow or late validators delay block finalization — not because of dishonesty, but due to timing and propagation lag.The network stays secure, but finality becomes slower until stragglers catch up
-> ERC-20 Transfer           - 21000 gas   - Only updates sender/receiver balances
   - DEX Swap (single hop)   - 110k-160k   - Two token transfers + reserve updates + swap math
   - DEX Swap (multi-hop)    - 180k-230k+  - Each hop is another pair contract execution
-> merkle trees , signatures 
-> mass scaling strategy 
    - snarks for execution layer
    - Data Availability Sampling (DAS) or known as peer DAS for blobs
        - Data Availability Sampling (DAS) in Ethereum is a technique that allows nodes to verify that all the data of a block is published without actually downloading the whole block ( with the helof of KZG commitmebts )
-> with an end to end formal verification , there can be zero bugs in the system
-> ZKEVMs change what current validators are doing like from execute everything to just verifying things
    - prover will be the new actor with ZKEVMs
    - proposers ( block builder validators ) are not sophisticated enough to build most economically valuable blocks possible and so instead they will deligate to most sophisticated that will do that on their behalf and this is called PBS ( Proposer Builder Separation )
-> ACD = All Core Devs in Ethereum.
    - It's the main technical governance process where client teams, researchers, and core contributors meet to coordinate protocol upgrades (hardforks)
-> current finality time is 2 epochs which is 64 slots 
-> Hardfork - A backward-incompatible upgrade
   SoftFork - A backward-compatible upgrade
   Temporary Fork (Uncle Fork) - This is not a protocol upgrade, but a naturally occurring fork when two miners/validators produce blocks at nearly the same time
-> Fork-choice rule (LMD-GHOST) ( Latest Message Driven - Greediest Heaviest Observed SubTree ) decides the head
-> All validators must submit one attestation per epoch, but committee members submit one per slot.
-> EIP ( difference between EIP and ERC )
    ├─ Core (protocol rules, consensus changes)
    ├─ Networking (peer-to-peer changes)
    ├─ Interface (JSON-RPC, APIs)
    └─ Standards Track
       └─ ERC (application-level smart contract standards)
       - ERC was a type of EIP
-> Transaction Types :: 
    - type 0 legacy transactions
    - type 1 transactions((introduced by EIP-2930)) introduces access list - An access list is a list of addresses and storage slots that your transaction promises it will touch during execution.
        - Type-1 tx lets you pre-warm those provided address/storage → reducing total gas.
    - type 2 - Added better gas fee hanhdling
    - type 3 - blob transactions
    - type 4 - EIP 7702 transactions ( for account abstraction our wallet will create this type of transaction )
-> max priority will be a bit more than the max fee that we are willing to pay ( this is becuase , we are saying that we are willing to pay this amount of eth and in the mean while if the base fee increases our transaction will revert )
-> DID :: Decentralized Identities
-> SBTs ( Soul Bound Tokens ) :: A token that cannot be transferred, only minted to and bound to a wallet.
-> how does ethereum knows when to complete and finalize that block as block limit is not reached
    - A validator is assigned a slot (12 seconds long) to propose a block.
    - When its turn arrives, it includes as many transactions as it can (or wants), up to the 30M gas limit.
    - It publishes the block when the 12-second slot ends, even if only 1M gas was used.
-> For Mev protection we can use Flash bots
->  In the context of decentralized finance, what is the main purpose of a DEX aggregator like 1inch or Matcha ?
    - To search across multiple decentralized exchanges to find the best possible price and most efficient route for a token swap.


questions
How monad is parallyzing evm
How megaeth does the tasks in a heterogeneous way , by doing singular task
How railgun privacy works


need to check zcash 
    - once there was bug to mint arbitary number of tokens ( and we cant able to see becuase it is private)
        - how can a blockchain be so private that we dont know the info too
