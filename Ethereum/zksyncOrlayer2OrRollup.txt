-> System contracts - Difference between Zksync and Ethereum Mainnet 
   - System contracts are a specialized set of contracts in virtual machines (VM) that enhance the Ethereum Virtual Machine (EVM) by supporting opcodes not available by default
   - https://docs.zksync.io/zksync-protocol/contracts/system-contracts
-> system contract call - SystemContractsCaller.systemCallWithPropagatedRevert
-> foundryup-zksync
-> forge build --zksync
-> Contracts with a large number of instructions will not compile on ZKsync due to the 65535 addressable space limitation imposed by zksolc
-> The zksolc compiler enforces a limit on the number of instructions a contract can have, capped at 2^16 instructions. If a contract 
     exceeds this limit, the compilation will fail.
-> Sequencer responsibilities
     - Accept user transactions. 
     - Reads user transactions from an L2 mempool
     - Order and execute transactions. 
     - Batch transactions for submission to Ethereum L1.
     - Provide fast but non-final confirmations.
-> zero knowledge proofs - the ability to prove honest computation without revealing the inputs 
-> circum and snarkjs - DSL for zksnarks
-> when we have 4 inputs in a merkle tree - Proof 1 = Hash 2 , Proof 2 = Hash 3-4 ( These are the proofs that we are going to provide 
     for the first input as an aarray of proofs)
->                                            Merkle Root
                                               H0
                            ___________________|___________________
                           |                                       |
                          H1                                       H2
                ___________|__________                  ___________|__________
               |                      |                |                      |
              H3                     H4              H5                     H6
         ______|______         ______|______     ______|______         ______|______
        |             |       |             |   |             |       |             |
       H7            H8      H9           H10  H11          H12      H13          H14
      / \           / \     / \          / \   / \          / \      / \          / \
    L0  L1       L2  L3   L4  L5      L6  L7 L8  L9     L10  L11  L12  L13    L14  L15
     |___ Single Node Layer for Remaining Nodes |      L16   L17  L18   L19

-> Leaf Node to Verify: L0
   Merkle Proof: The following sibling hashes are required to reconstruct the path to the root:
   L1
   H8 (sibling of H7)
   H4 (sibling of H3)
   H2 (sibling of H1)
-> zkSync uses two nonces: a deployment nonce (for create calls) and a transaction nonce (for replay protection). This affects contract 
     address calculation, so tweak your Foundry scripts accordingly
-> STARKs (succinct zero-knowledge proofs without trusted setup)
-> Validium's mechanism is very similar to a zkRollup, the only difference being that data-availability in a zkRollup is on-chain, while 
   Validium keeps it off-chain. This permits Validium to achieve considerably higher throughput
-> what is validium ? ( exchange validiums or exhchange proof of solvency) - exchanges can able to prove each and every coin 
   of the deposits they got and they have that corresponding coins and ther are not being fractional reserves
   - https://www.youtube.com/watch?v=5GvoJhwhv8E
   - Funds belonging to validium users are controlled by a smart contract on Ethereum
   - However, validium users can have their funds frozen and withdrawals restricted. This can happen if data availability managers (Data Availability Committee (DAC)) on the validium chain withhold offchain state data from users. Without access to transaction data, users cannot compute the Merkle proof required to prove ownership of funds and execute withdrawals
   - https://ethereum.org/en/developers/docs/scaling/validium/
   - In zkSync 2.0, the L2 state will be divided into 2 sides: zkRollup with on-chain data availability and zkPorter with off-chain data availability.
   - zkPorter accounts can make thousands of swaps on the Uniswap contract, but only a single update needs to be published to Ethereum
   - Volition
-> The rollup's state is available to the zkRollup users as long as at least one Ethereum full node is online
-> what is zero knowledge proof of transaction history ?
-> SNARKS cost to verify on ETH (SNARK verifiers) ( 270k gas for plonk proof and 11 million gas for a STARK proof)
-> In order for a Zero knowledge to be valid , It must need to satisy three fundamental properties
   - Completeness    - if the statement is true, an honest prover must convince the verifier if they have the knowledge of the witness
   - Soundness       - if the statement if false, no dishonest prover can convince an honest verifier with an invaid witness
   - Zero Knowledge  - The verifier must learn nothing except that the prover's statement is true
-> ZKPs sytems comprises of two components
   - front-end - the frontend is the constraint system it is where the problem is defined mathematically
   - back-end - proving system - Takes the compiled circuits and generates the proof - verifies the proof
-> Type of zero knowledge proofs
   - Interactive zero knowledge proofs (IZKPs)
      - In interactive ZKPs, the prover and verifier engage in a back-and-forth conversation. The verifier sends random challenges, and the prover responds to each one in real-time.
   - non-interactive zero knowledge proofs
         - Non-interactive proofs require no back-and-forth communication. The prover generates a single proof that the verifier can check independently.
         - snarks ( needs trusted setup ) 
            - trusted setup - A trusted setup ceremony is a procedure that is done once to generate some data that must be used every time some cryptographic (ZK in this instance) protocol is run
                           - The trusted setup is a one-time ceremony that generates public parameters â€” special cryptographic data that both the prover and verifier will use
                           - The system is designed to be secure as long as at least one participant is honest and destroys their secret
                - toxic waste - during initial setup some random numbers will be generated and these needs to be securely destroyed, if an attacker knows these values he can forge an invalid proofs and that will pass the verification
                - CRS (common reference string) - A set of public parameters that both the prover and verifier use in the proof generation and verification processes
                    - SRS ( Structure reference string ) - data is specific format, EX: elliptic curve points
                - Multi party computation (MPC)  - https://grok.com/chat/a02ae464-9842-4ac6-885f-f6659211d5dc
                - polynomial commitment - EX : KZG commitment
                - Examples 1) Circuit specific (Groth16) - The cryptographic parameters need to be regenerated for every circuit
                        -  2) universal (plonk) - The cryptographic parametes can be reused ( for circuits upto a certain size )
            - plonk
            - groth16
         - starks
         - bulletproofs
   - https://grok.com/share/bGVnYWN5_b9d43569-2ffa-46b3-9432-573d66b96f10
   - https://x.com/panditdhamdhere/status/1925894438988951680
-> Terminology 
   - Constraint - Mathematical condition which must be satisfied in order for the claim to be valid
      - constraints define the rules the inputs ( private (only prover knows) and public (both prover and verifier know) inputs ) must follow
      - written using Circom or NOA
   - Circuit - A system of constraints makes up the circuit
        - The circuit defines how the constraints work together 
   - Witness - The set of private values that allow a prover to demonstrate that their claim or statement is valid/true
         - THe witness must satisfy the constraints of the circuit
   - prover - The prover is the entity that generates the proof of computation to demonstate the knowledge of witness while satisying the circut constraints
-> Proof of web2 data ( private web data to onchain ) ( DECO - Data Enabled Computation Oracle)