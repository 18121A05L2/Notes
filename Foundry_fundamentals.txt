--> forge script script/DeploySimpleStorage.s.sol --rpc-url http://127.0.0.1:8545 --broadcast --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
--> forge script script/DeploySimpleStorage.s.sol --rpc-url http://localhost:8545 --account one_anvil --broadcast
-> forge create EIP7702 --from <anvilAddress> --unlocked --broadcast
--> source .env --> forge script script/DeploySimpleStorage.s.sol --rpc-url $SEPOLIA_URL --private-key $PRIVATE_KEY --broadcast
--> (storing private key) cast wallet import one_anvil --interactive
--> cast send 0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9 "store(uint256)" 345 --account one_anvilca
--> foundryup , foundryup-zksync
--> forge fmt
--> forge coverage
--> forge coverage --report debug > coverage.txt
--> forge test --debug <TestFunctionName>
--> forge test --match-test <TestFunctionName>
--> forge test --fork-url $MAINNET_RPC_URL --fork-block-number $BLOCK_NUMBER
--> cast call 0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9 "retrieve()" ( Only to Read Information from blockchain )
    - 0x0000000000000000000000000000000000000000000000000000000000000159
--> cast --to-base 0x0000000000000000000000000000000000000000000000000000000000000159 dec
    - 345
--> To install a dependency - forge install smartcontractkit/chainlink-brownie-contracts --no-commit
--> setUp() in test will run each time a test function is executed
--> Generate a gas snapshot file - forge snapshot -m <testFunctionName>
--> forge inspect FundMe storageLayout
--> forge inspect <contractAddress> methods - will print all functions with its selectors
--> cast storage <contractAddress>
--> cast code <contractAddress>
--> cast storage <contractAddress> <slotnumber> --rpc-url $LOCAL_RPC_URL
--> cast parse-bytes32-string <bytes32>
--> cast sig "fund()" - will return the hex code of the selector
--> cast --calldata-decode "transferFrom(address,address, uint256)" <CallData> -  provides the ouptut of argument values
--> Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.
--> security audit analysis - python3 -m pip install slither-analyzer 
--> Solidity's integer division truncates. Thus, performing division before multiplication can lead to precision loss.
--> 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38 - default sender of foundry
--> For vm.sign() the address we have passed need to be unlocked
--> console2 has upto 5 arguments where as for console we have only upto 3 arguments
--> ZKSYNC - forge create --zksync --rpc-url ${ZKSYNC_SEPOLIA_RPC} --private-key ${PRIVATE_KEY} src/Counter.sol:Counter
--> For example, the verbosity levels of the EVM are:
        - 2 (-vv): Print logs for all tests.
        - 3 (-vvv): Print execution traces for failing tests.
        - 4 (-vvvv): Print execution traces for all tests, and setup traces for failing tests.
        - 5 (-vvvvv): Print execution and setup traces for all tests, including storage changes.
--> Foundry wallets are store in this location - ~/.foundry/keystores/
--> makePersistant- Each fork (createFork) has its own independent storage, which is also replaced when another fork is selected (selectFork). 
    By default, only the test contract account and the caller are persistent across forks, which means that changes to the state of the test 
    contract (variables) are preserved when different forks are selected. This way data can be shared by storing it in the contract's variables
--> via_ir=true or --via-ir for New Intermedite Representation
--> Solidity can generate EVM bytecode in two different ways: Either directly from Solidity to EVM opcodes (“old codegen”) 
    or through an intermediate representation (“IR”) in Yul (“new codegen” or “IR-based codegen”)
--> cast 4byte 0xdd62ed3e
--> Installing multiple versions of same dependency - forge install openzeppelin-contracts-v3=Openzeppelin Gihub link
--> When you start a prank with vm.startPrank(player), all subsequent calls occur in a single simulated transaction. In this context, the
     account's nonce isn't incremented between calls because they're not separate transactions they're part of one execution context.
--> Reading Private key - deployerKey = vm.envUint("PRIVATE_KEY");
--> vm.startPrank only pranks the msg.sender on external contract calls.
    - Internal calls (including library/internal functions and console.log in your test) remain in the original execution context.
        vm.startPrank(admin);
        console.log("admin : ", admin);
        console.log("msg.sender : ", msg.sender);
    - here msg.sender and admin were different
--> vm.warp(1 hours) - Absolute warps do NOT accumulate—they just set the timestamp to the given value.
    vm.warp(block.timestamp + 1) - Relative warps accumulate, so the timestamp is moved forward by the given value.
        - this mean , it does includes the previous vm.warp(1 hours)
--> startPrank overriding issue - https://github.com/foundry-rs/foundry/issues/10310
--> anvil --load-state initital_state.json ( need to try one example with , cast send )
    - --block-time 5 (This will mine the block with the given interval, here 5 seconds)
--> EIP-7702 Delegator - cast send $(cast az) --private-key $alice_pk --auth $(cast wallet sign-auth $DelegateContractV0 --private-key $bob_pk )
    - Adding delegator for bob signature using alice
    - anvil --hardfork prague