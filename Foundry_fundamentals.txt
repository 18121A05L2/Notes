--> forge script script/DeploySimpleStorage.s.sol --rpc-url http://127.0.0.1:8545 --broadcast --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
--> forge script script/DeploySimpleStorage.s.sol --rpc-url http://localhost:8545 --account one_anvil --broadcast
--> source .env --> forge script script/DeploySimpleStorage.s.sol --rpc-url $SEPOLIA_URL --private-key $PRIVATE_KEY --broadcast
--> (storing private key) cast wallet import one_anvil --interactive
--> cast send 0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9 "store(uint256)" 345 --account one_anvilca
--> foundryup , foundryup-zksync
--> forge fmt
--> forge coverage
--> forge coverage --report debug > coverage.txt
--> forge test --debug <TestFunctionName>
--> forge test --match-test <TestFunctionName>
--> cast call 0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9 "retrieve()" ( Only to Read Information from blockchain )
    - 0x0000000000000000000000000000000000000000000000000000000000000159
--> cast --to-base 0x0000000000000000000000000000000000000000000000000000000000000159 dec
    - 345
--> To install a dependency - forge install smartcontractkit/chainlink-brownie-contracts --no-commit
--> setUp() in test will run each time a test function is executed
--> Generate a gas snapshot file - forge snapshot -m <testFunctionName>
--> forge inspect FundMe storageLayout
--> cast storage <contractAddress>
--> cast parse-bytes32-string <bytes32>
--> cast storage <contractAddress> <slotnumber> --rpc-url $LOCAL_RPC_URL
--> cast sig "fund()" - will return the hex code of the selector
--> cast --calldata-decode "transferFrom(address,address, uint256)" <CallData> -  provides the ouptut of argument values
--> FUZZ Testing
--> Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.
--> forge inspect <contractAddress> methods - will print all functions with its selectors
--> security audit analysis - python3 -m pip install slither-analyzer 
--> Solidity's integer division truncates. Thus, performing division before multiplication can lead to precision loss.
--> forge test --fork-url $MAINNET_RPC_URL --fork-block-number $BLOCK_NUMBER
--> 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38 - default sender of foundry
--> For vm.sign() the address we have passed need to be unlocked
--> console2 has upto 5 arguments where as for console we have only upto 3 arguments
--> ZKSYNC - forge create --zksync --rpc-url ${ZKSYNC_SEPOLIA_RPC} --private-key ${PRIVATE_KEY} src/Counter.sol:Counter
--> For example, the verbosity levels of the EVM are:
        - 2 (-vv): Print logs for all tests.
        - 3 (-vvv): Print execution traces for failing tests.
        - 4 (-vvvv): Print execution traces for all tests, and setup traces for failing tests.
        - 5 (-vvvvv): Print execution and setup traces for all tests, including storage changes.
--> Foundry wallets are store in this location - ~/.foundry/keystores/
--> makePersistant- Each fork (createFork) has its own independent storage, which is also replaced when another fork is selected (selectFork). 
    By default, only the test contract account and the caller are persistent across forks, which means that changes to the state of the test 
    contract (variables) are preserved when different forks are selected. This way data can be shared by storing it in the contract’s variables
--> via_ir=true or --via-ir for New Intermedite Representation
--> Solidity can generate EVM bytecode in two different ways: Either directly from Solidity to EVM opcodes (“old codegen”) 
    or through an intermediate representation (“IR”) in Yul (“new codegen” or “IR-based codegen”)
--> cast 4byte 0xdd62ed3e
--> Installing multiple versions of same dependency - forge install openzeppelin-contracts-v3=Openzeppelin Gihub link
--> When you start a prank with vm.startPrank(player), all subsequent calls occur in a single simulated transaction. In this context, the account’s nonce isn’t incremented between calls because they're not separate transactions—they're part of one execution context.
--> Reading Private key - deployerKey = vm.envUint("PRIVATE_KEY");