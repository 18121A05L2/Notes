-> React is a library for building user interfaces , it was not a framework
-> Hooks - state , context , useRef , forwardRef , effect and performance 
-> npx - npm package runner
    - Does not install globally: npx downloads and runs the latest version of create-react-app temporarily.
-> Peer dependencies need to be specified in the libraries ( like whoever are publishing packages to npm )
-> useCallback hook memoizes the function itself, not its return value. useMemo caches the functions return value so that the function need not execute again
-> useCallback - if we have a function in a component and it will create each time when a component is rendered , with this it wont recreate until unless dependencies of it are changed
-> Portals - Render children into a DOM node outside the parent hierarchy (e.g., for modals).
    - Event bubbling in portal works just like the normal child components in the parent hierarchy.
-> Streaming allows you to break down the page's HTML into smaller chunks and progressively send those chunks from the server to the client.
-> Context API - we will provide the state and dispatch when wrapping contextProvider and use those using useContext
-> useRef -  To persist a mutable value across renders without triggering re-renders 
    - Accessing DOM elements
-> Rendering - The commit phase is usually fast but the render phase can be slow.
    - same value after rerenders , react will render one more time for that component and bails out from any subsequest renders
    - In React, the rendering process is divided into two main phases: the “render phase” and the “commit phase
    - React looks for any useEffect hooks declared in the component in the commit phase and executes their effect functions
    - (non primitive data types) same array and object references does not queue up for re-renders
    - (if parent re-renders) the child components would went through the render phase but not commit phase
-> React.memo comes with an extra cost
-> Noraml Script - Html parsing (and if it encounter any script tag) + fetch the script tag resources + execute the script tag js and then continue HTML parsing
-> Async Script - Html parsing (and if it encounter any script tag) + execute the script tag js and then continue HTML parsing
                             + fetch the script tag resources in parallel
-> defer script - HTML parsing                              After HTML parsing is done + execute the scripts fetched in parallel
                    + fetch scripts resources in parallel
-> Async does not guarantee the order of execution but defer does
-> Transitive dependency: A module that you didn't install directly, but one of your direct dependencies did
-> useEffects runs after the rendering of the page
-> In short, useEffect is a tool that lets us interact with the outside world but not affect the rendering or performance of the component that it's in
-> Packages : React Router DOM 
-> MERN STACK  --  https://www.mongodb.com/languages/mern-stack-tutorial
-> differences  
   - mount and unmount
-> useLayoutEffect runs BEFORE the browser updates the screen (the "paint").Use it when your code needs to change the layout or measure a DOM element before the user sees it. This prevents an annoying visual "flicker" or "flash." Think of adjusting scroll position or element sizes right after a state update
-> What happens to theuseEffect hook in the case of SSR?
    - The useEffect doesn't get executed as there is no DOM in the server and there is no commit happening in SSR.
    - It does run, but only on the client after hydration, even if SSR was used.
    - SSR never commits because commit only happens in the browser